<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Penalty Constraints - Optiseek</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Penalty Constraints";
        var mkdocs_page_input_path = "penalty_constraints.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Optiseek
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../examples/">Quick Start Examples</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">optiseek API</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="#">.variables</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../variables/">Variable Types</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">.metaheuristics</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="#">Population-Based Methods</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../particle_swarm_optimization/">Particle Swarm Optimizer</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../differential_evolution/">Differential Evolution</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../firefly_algorithm/">Firefly Algorithm</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../mayfly_algorithm/">Mayfly Algorithm</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../flying_foxes_algorithm/">Flying Foxes Algorithm</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="#">Local Search Methods</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../simulated_annealing/">Simulated Annealing</a>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">.modelhelpers</a>
    <ul class="current">
                <li class="toctree-l2 current"><a class="reference internal current" href="./">Penalty Constraints</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../parameter_grid_search/">Parameter Grid Search</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">.testfunctions</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../ackley/">Ackley Function</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../booth/">Booth Function</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../rosenbrock/">Rosenbrock Function</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../wheelers_ridge/">Wheeler's Ridge</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Optiseek</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>optiseek API &raquo;</li>
          <li>.modelhelpers &raquo;</li><li>Penalty Constraints</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>

          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="penalty-constraints">Penalty Constraints</h1>
<p>This function allows the user to apply constraints to an objective function as penalties and will return a new penalized function that can be optimized.
Both counted penalties and quadratic penalties can be enforced with this function.</p>
<p>Shown below is a representation of a 1D function <em>f(x)</em> and how it is penalized by both counted and quadratic constraints.
In this case, the constraints are that the function input <em>x</em> cannot be less than <em>A</em> or greater than <em>B</em>. With either of these constraint types, as soon as a
constraint is violated, the function value <em>y</em> has a penalty added to it. For the quadratic penalty, this penalty increases quadratically by the magnitude that 
the constraint is violated by. For the counted penalty, there is a fixed amount added to the function value for every penalty that is broken, regardless of the 
magnitude it is violated by.</p>
<p><img alt="Penalty Constraint Graphic" src="../images/penalty_constraint_graphic.png" /></p>
<p>It should be noted that the counted penalty creates a sharp discontinuity in the function, while the quadratic penalty is smooth. Typically, use of the quadratic penalty
will result in better convergence of the optimization algorithm; however, there are situations where the function value is optimal at
the location where a constraint is applied (like at <em>A</em> in the graphic above). In this case, the quadratic penalty multiplier will need to approach infinity
in order for the constraint to be properly enforced. In situations like this, it may be beneficial to use a moderate quadratic penalty with a small counted penalty.
Applying penalty constraints does not guarantee that the optimization algorithm will converge at a point within the constraints. Oftentimes, the penalty multipliers
must be tuned by the user to find out what works best.</p>
<p>Parameters of the <code>optiseek</code> <em>penalty_constraints</em> function allow the user to control the magnitude of each of these penalties. 
Combinations of both of these penalty types can be applied at once with a single <em>penalty_constraints</em> function call. A value of zero will result in
no penalty of that type being applied to the returned penalized function. A higher value increases the step height for count penalties and increases the slope for
quadratic penalties. This tool will work for any function, whether the user would like to find the minimum or maximum.</p>
<hr />
<blockquote>
<p><em>function</em> optiseek.modelhelpers.<strong>penalty_constraints</strong>(<em>input_function, constraint_dict, find_minimum=True, p_quadratic=1, p_count=0</em>)</p>
</blockquote>
<hr />
<h3 id="parameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>input_function : <em>function</em></td>
<td>Function object for the algorithm to optimize.</td>
</tr>
<tr>
<td>constraint_dict : <em>dict</em></td>
<td>A dictionary that contains any number of constraint equations<br/> to be applied to the input function. The dictionary is structured<br/> like {constraint function: constraint type} where the constraints<br/> are compared to zero with a mathematical operator:<br/> g1(x) = 0, g2(x) &lt; 0, etc. The constraint function must share<br/> the same arguments in the same order as the objective<br/> function. The constraint type must be one of the following<br/> strings: "&lt;", "&lt;=", "&gt;", "&gt;=", "=". See the example for more<br/> information.</td>
</tr>
<tr>
<td>find_minimum : <em>bool</em></td>
<td>Indicates whether the optimimum of interest is a minimum<br/> or maximum. If true, looks for minimum. If false,<br/> looks for maximum.</td>
</tr>
<tr>
<td>p_quadratic : <em>float</em></td>
<td>Penalty multiplier for the quadratic penalty in [0, inf]. A value of zero will<br/> result in no quadratic penalty to the objective function. A nonzero value<br/> smoothly penalizes the function according to the magnitude that the<br/> constraint is broken. Default value is 1.</td>
</tr>
<tr>
<td>p_count : <em>float</em></td>
<td>Penalty multiplier for the count penalty in [0, inf]. A value of zero will<br/> result in no count penalty to the objective function. A nonzero value<br/> creates a sharp discontinuity where the constraint is broken. Default<br/> value is 0.</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="returns">Returns</h3>
<table>
<thead>
<tr>
<th>Returns</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>penalized_function : <em>function</em></td>
<td>A function representing the input objective function with the<br/> constraints applied as penalties to the function value.</td>
</tr>
<tr>
<td>check_constraints : <em>function</em></td>
<td>A function that, when passed some inputs, returns a list of booleans<br/> that represent whether each constraint was satisfied (True) or<br/> broken (False). Inputs to this function are the exact same as<br/> the input function.</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="example-1">Example 1:</h3>
<p>We can demonstrate these constraints on a problem with several complex constraint equations to see it in action! Shown below is an engineering optimization problem
taken from an article by Xin-She Yang (see references) based on the properties of a spring. The function, its constraints, and the variable bounds are given.
Note that in this example, we choose to use a quadratic penalty multiplier of 2 and no counted penalty at all. Also note that the constraint functions must share the
same arguments in the same order as the input function.</p>
<p><img alt="Spring Problem Graphic" src="../images/example_spring_problem.png" /></p>
<pre><code class="language-python">from optiseek.variables import var_float
from optiseek.modelhelpers import penalty_constraints
from optiseek.metaheuristics import flying_foxes_algorithm

# create the function definition
def spring_problem(x1, x2, x3):
    return x1 ** 2 * x2 * (2 + x3)

# create the constraints as functions
def g1(x1, x2, x3):
    return 1 - (x2 ** 3 * x3) / (71785 * x1 ** 4)

def g2(x1, x2, x3):
    return (4 * x2 ** 2 - x1 * x2) / (12566 * (x1 ** 3 * x2 - x1 ** 4)) + 1 / (5108 * x1 ** 2) - 1

def g3(x1, x2, x3):
    return 1 - (140.45 * x1) / (x2 ** 3 * x3)

def g4(x1, x2, x3):
    return (x1 + x2) / 1.5 - 1

# create the constraint dictionary to define the constraint type
spring_constraint_dict = {g1: &quot;&lt;=&quot;,
                          g2: &quot;&lt;=&quot;,
                          g3: &quot;&lt;=&quot;,
                          g4: &quot;&lt;=&quot;}

# create a constrained version of the original function to be optimized
spring_problem_const, const_check = penalty_constraints(spring_problem,
                                                        spring_constraint_dict,
                                                        find_minimum=True,
                                                        p_quadratic=5000,
                                                        p_count=0)

# define variable list and search domain
var_list = [
    var_float('x1', [0.05, 2.0]),
    var_float('x2', [0.25, 1.3]),
    var_float('x3', [2.0, 15.0])
]

# instantiate an optimization algorithm with the constrained function and search domain
alg = flying_foxes_algorithm(spring_problem_const, var_list)

# optimize and check to make sure constraints are satisfied
alg.optimize(find_minimum=True, max_iter=500)
constraint_bools = const_check(*alg.best_position.values())

# show the results!
print(f'best_value = {alg.best_value:.5f}')
print(f'best_position = {alg.best_position}')
print(f'n_iter = {alg.completed_iter}')
print(f'constraint check: {constraint_bools}')
</code></pre>
<pre><code class="language-profile">best_value = 0.01267
best_position = {'x1': 0.0517568175037568, 'x2': 0.35827540281247405, 'x3': 11.201295780064102}
n_iter = 500
constraint check: [True, True, True, True]
</code></pre>
<p>With this code, the best found solution found was approximately [0.0517, 0.358, 11.20].
A very high penalty constraint value was necessary, as the constraints made the search space much more complex.
We also used the constraint checking function created by the <code>penalty_constraints</code> helper to verify that our constraints were indeed satisfied with the best solution.
Note that this is not guaranteed to be the global optimum.</p>
<hr />
<h3 id="example-2">Example 2:</h3>
<p>In this generic problem, the constraints require a bit more work to implement. 
The <em>constraint_dict</em> parameter for the penalty constraints function requires the constraints to be compared to zero.<br />
We must re-arrange the constraint equations to ensure this. 
Also, we can assume an upper bound on the search domain of 20 for each variable.</p>
<p><em>Note: This is a linear problem, and could be easily solved with linear programming as well. However, it is a good example for re-arranging constraint functions.</em></p>
<p><img alt="Linear Problem Statement" src="../images/example_linear_1.png" /></p>
<p>First, we will re-arrange the constraints. We can use the minimum value for x, y, and z to help define the search space.</p>
<p><img alt="Linear Constraints" src="../images/example_linear_2.png" /></p>
<pre><code class="language-python">from optiseek.variables import var_float
from optiseek.modelhelpers import penalty_constraints
from optiseek.metaheuristics import flying_foxes_algorithm

# create the function definition
def linear_function(x, y, z):
    return -2 * x - 3 * y - 4 * z

# create the constraints as functions
def g1(x, y, z):
    return 3 * x + 2 * y + z - 10

def g2(x, y, z):
    return 2 * x + 5 * y + 3 * z - 15

# create the constraint dictionary to define the constraint type
constraint_dict = {g1: &quot;&lt;=&quot;, g2: &quot;&lt;=&quot;}

# create a constrained version of the original function to be optimized
linear_function_const, const_check = penalty_constraints(linear_function,
                                                         constraint_dict,
                                                         p_quadratic=50000,
                                                         p_count=0)

# define variable list and search domain
var_list = [
    var_float('x', [0, 20]),
    var_float('y', [0, 20]),
    var_float('z', [0, 20])
]

# instantiate an optimization algorithm with the constrained function and search domain
alg = flying_foxes_algorithm(linear_function_const, var_list)

# optimize and check to make sure constraints are satisfied
alg.optimize(find_minimum=True, max_iter=200)
constraint_bools = const_check(*alg.best_position.values())

# show the results!
print(f'best_value = {alg.best_value:.5f}')
print(f'best_position = {alg.best_position}')
print(f'n_iter = {alg.completed_iter}')
print(f'constraint check: {constraint_bools}')
</code></pre>
<pre><code class="language-profile">best_value = -19.99982
best_position = {'x': 0.0, 'y': 0.0, 'z': 4.9999547568628735}
n_iter = 200
constraint check: [True, True]
</code></pre>
<p>With this code, it can be found that the best solution is approximately <em>f(0, 0, 5) = -20</em>.</p>
<hr />
<h3 id="references">References</h3>
<p><em>Algorithms for Optimization by Kochenderfer and Wheeler, Chapter 10.7</em></p>
<p><a href="http://www.scholarpedia.org/article/Metaheuristic_Optimization">Spring Example Problem by Xin-She Yang</a></p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../simulated_annealing/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../parameter_grid_search/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
